# WWDC17-Scholarship-Submission

For my playground, I have created a 2D hockey game using the macOS SDK. Specifically, the game uses SpriteKit for graphics and physics simulation, and GameplayKit for controlling players not currently selected by the user.

For controlling the selected player, the playground uses keyDown and keyUp events. I have implemented the common “WASD” layout for player movement. Passing the puck is achieved by pressing the space bar, while shooting towards the net is achieved with the up arrow key.

SpriteKit was used to create the visuals and physics of the game. The 2D game technology allowed me to create nodes for both nets, the puck, and all of the players in the game, and add physics bodies to them. Actions like picking up the puck and knocking an opposing player off the puck were achieved through SKContactDelegate. A Player entity colliding with a loose puck where the contact point is located in front of the player causes that Player to pick up the puck. Similarly, an opposing Player colliding with the puck carrier at or above a certain impulse magnitude results in the puck carrier losing control of the puck. To create animations for skating and shooting the puck, I created player textures for each frame of the animation, and animate through them by adding a SKAction object to the player’s node. Player actions like passing and shooting the puck were also achieved using SKAction. 

After finishing the basics of the game, I moved on to integrating GameplayKit. This process began with refactoring my code from classes for each node with all associated logic packaged inside into entities and components. I created GKEntity subclasses for the nets, puck, and players, and GKComponent subclasses for the player, net, and puck game logic, user control, and player movement. Refactoring to this organization made it very easy to add and remove functionality from the GKEntity subclasses. For example, when a player on the user controlled team is selected, a UserComponent object is added to the Player entity, and the MoveComponent object is removed. 

To control unselected players on both teams, I implemented agents, goals, and behaviors. Both the MoveComponent and UserComponent classes inherit from GKAgent2D, and the agent’s position for both of these classes are updated using GKAgentDelegate. Since these two classes are “substitutes” for each other, the Player entity contains a computed variable that returns the active agent. This is used when creating goals for a GKBehavior. For this playground, there are six behaviors that can be set to a Player’s MoveComponent: chase the puck, defend, attack the puck carrier, attack the goal, wander, and supporting the puck carrier. Behaviors are updated for all Player objects in the scene whenever the puck is released or acquired by a Player using the PlayerComponent’s updateMoveComponent(withType: BehaviorType) method.
